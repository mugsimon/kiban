(define (myeval exp env)
  (if (not (pair? exp))
      (cond ((or (number? exp)
		 (boolean? exp)) exp)
	    ((symbol? exp)
	     (lookup-variable-value
	      exp env)))
      (case (car exp)
	((quote) (cadr exp))
	((lambda)
	 (list 'function ;tag
	       (cadr exp) ;parameters
	       (caddr exp) ;body
	       env))
	((if)
	 (if (true? (myeval (cadr exp) env))
	     (myeval (caddr exp) env)
	     (if (null? (cdddr exp))
		 #f ;
		 (myeval (cadddr exp) env))))
	((define)
	 (define-variable!
	   (cadr exp) ;variable name
	   (myeval (caddr exp) env)
	   env)
	 'ok)
	(else
	 (myapply (myeval (car exp) env)
		  (map (lambda (x) (myeval x env))
		       (cdr exp)))))))
(define (myapply func arguments)
  (case (car func)
    ((primitive)
     (apply-primitive-function func
			       arguments))
    ((function)
     (myeval (caddr func) ;body
	     (extend-environment ;extending environment
	      (cadr func) ;parameters
	      arguments 
	      (cadddr func)))) ;env
    (else
     (error "Unknown procedure type -- APPLY"
	    func))))
(define (true? x) (not (eq? x #f)))
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (cons vars vals) base-env)
      (if (< (length vars) (length vals))
	  (error "Too many arguments supplied"
		 vars vals)
	  (error "Too few arguments supplied"
		 vars vals))))
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
	     (env-loop (cdr env)))
	    ((eq? var (car vars)) (car vals))
	    (else (scan (cdr vars) (cdr vals)))))
    (if (null? env)
	(error "Unbound variable" var)
	(let ((frame (car env)))
	  (scan (car frame) (cdr frame)))))
  (env-loop env))
(define (define-variable! var val env)
  (let ((frame (car env)))
    (define (scan vars vals)
      (cond ((null? vars)
	     (set-car! frame (cons var (car frame)))
	     (set-cdr! frame (cons val (cdr frame))))
	    ((eq? var (car vars))
	     (set-car! vals val))
	    (else
	     (scan (cdr vars) (cdr vals)))))
    (scan (car frame) (cdr frame))))
(define (setup-environment)
  (extend-environment
   '(car cdr cons null? = < + - *)
   (map (lambda (f) (cons 'primitive f))
	(list car cdr cons null? = < + - *))
   '()))
(define the-global-environment
  (setup-environment))
(define (apply-primitive-function func args)
  (apply (cdr func) args))
(define (driver-loop)
  (newline) (display "> ")
  (flush)
  (let ((input (read)))
    (let ((output
	   (myeval input the-global-environment)))
      (if (and (pair? output)
	       (eq? (car output) 'function))
	  (display (list 'compound-function
			 (cadr output)
			 (caddr output)
			 '<function-env>))
	  (display output))))
  (driver-loop))


;; 
(define (analyze exp)
  (cond ((self-evaluating? exp)
	 (analyze-self-evaluating exp))
	((quoted? exp)
	 (analyze-quoted exp))
	((variable? exp)
	 (analyze-variable exp))
	((assignment? exp)
	 (analyze-assignment exp))
	((definition? exp)
	 (analyze-definition exp))
	((if? exp)
	 (analyze-if exp))
	((lambda? exp)
	 (analyze-lambda exp))
	((begin? exp)
	 (analyze-sequence (begin-actions exp)))
	((cond? exp)
	 (analyze (cond->if exp)))
	((application? exp)
	 (analyze-application exp))
	(else
	 (error "... -- ANALYZE" exp))))
(define (analyze-self-evaluating exp)
  (lambda (env) exp))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
	(vfun (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vfun env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
	(vfun (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vfun env) env)
      'ok)))
(define (analyze-if exp)
  (let ((pfun (analyze (if-predicate exp)))
	(cfun (analyze (if-consequent exp)))
	(afun (analyze (if-alternative exp))))
    (lambda (env)
      (if (true? (pfun env))
	  (cfun env)
	  (afun env)))))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
	(bfun (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-function vars bfun env))))
(define (analyze-sequence exps)
  (define (sequentially func1 func2)
    (lambda (env) (func1env) (func2 env)))
  (define (loop first-func rest-funcs)
    (if (null? rest-funcs)
	first-func
	(loop (sequentially first-func
			    (car rest-funcs))
	      (cdr rest-funcs))))
  (let ((funcs (map analyze exps)))
    (if (null? funcs)
	(error "Empty sequence -- analyze")
	(loop (car funcs) (cdr funcs)))))
(define (analyze-application exp)
  (let ((ffunc (analyze (operator exp)))
	(afuncs (map analyze (operands exp))))
    (lambda (env)
      (execute-application (ffunc env)
			   (map (lambda (afunc) (afunc env))
				afuncs)))))
(define (execute-application func args)
  (cond ((primitive-function? func)
	 (apply-primitive-function func args))
	((compound-function? func)
	 ((function-body func)
	  (extend-environment
	   (function-parameters func)
	   args
	   (function-environment func))))
	(else (error))))
(define (self-evaluating? exp)
  (cond ((number? exp) #t)
	((string? exp) #t)
	(else #f)))
(define (variable? exp) (symbol? exp))
(define (quoted? exp)
  (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
(define (assignment? exp)
  (tagged-list? exp 'set!))
(define (assignment-variable exp)
  (cadr exp))
(define (assignment-value exp)
  (caddr exp))
(define (definition? exp)
  (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
		   (cddr exp))))
(define (lambda? exp)
  (tagged-list? exp 'lambda))
(define (lambda-parameters exp)
  (cadr exp))
(define (lambda-body exp)
  (cddr exp))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
(define (if? exp)
  (tagged-list? exp 'if))
(define (if-predicate exp)
  (cadr exp))
(define (if-consequent exp)
  (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      #f))

(define (begin? exp)
  (tagged-list? exp 'begin))
